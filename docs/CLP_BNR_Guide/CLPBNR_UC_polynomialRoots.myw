#### Solving Polynomial Equations in one Variable

Finding the roots of a univariate polynomial equation is the same as asking what is the value of `X` given the constraint `{P(X)==0}`. (Some of this section was covered earlier in "Constraints on Real Intervals".) A simple quadratic with two real roots (1 and 3):
eg
	﻿?- X::real, {X**2-4*X+3 == 0}.
	X::real(0.9999999999999998, 3.0000000000000018).
The interval result must include both roots. To produce a single value, the problem must be further constrained:
eg
	?- X::real(2,_), {X**2-4*X+3 == 0}.
	﻿X:: 3.00000000000000... .
or to find both:
eg
	?- X::real, {X**2-4*X+3 == 0}, ({X=<2};{X>=2}).
	﻿X:: 1.000000000000000... ;
	X:: 3.00000000000000... .
Since we're looking for point solutions, `solve/1` is better than guessing at additional constraints to isolate roots:
eg
	?- X::real, {X**2-4*X+3 ==0}, solve(X).
	﻿X:: 1.000000000000000... ;
	X:: 3.00000000000000... .
	
Formulas exist for solving equations of low degree, so this may hardly seem to be worth the trouble, but this same technique works for pretty much any polynomial:
eg
	?- X::real, {17*X**256+35*X**17-99*X == 0}, solve(X).
	X:: 0.0000000000000000... ;
	X:: 1.005027892894011... .

	?- X::real, {35*X**256-14*X**17+X == 0}, solve(X).
	﻿X:: -0.847943660827315... ;
	X:: 0.﻿0000000000000000... ;
	X:: 0.847943660827315... ;
	X:: 0.995842494200498... .
A fourth degree polynomial equation with two real roots:
eg
	?- X::real, {X**4-4*X**3+4*X**2-4*X+3 == 0}, solve(X).
	X:: 1.00000... ;
	X:: 3.00000... ;
	false.
On occasion, `solve` may return in value which actually does not contain a solution, depending on the value of the precision parameter. Consider:
eg
	?- X::real, {X**2-2*X+1==0}, solve(X).
	X:: 1.000... ;
	false.
	% but
	?- X::real, {X**2-2*X+1==0}, solve(X,8).
	X:: 1.0000... ;
	X:: 1.00001022... ;
	false.
This simple polynomial has an asymptotic root at `X=1`, i.e., large changes in `X` result in fairly small changes in the polynomial's value which makes for hard work for constraint propagation. Increasing the precision doesn't help and in fact returns an interval which doesn't contain a root but the termination conditions for `solve` kick in before it can prove it. The `absolve/2` predicate with a low precision value can be used to remove this "spurious" value:
eg
	?- X::real, {X**2-2*X+1==0}, solve(X,8), absolve(X,2).
	X:: 1.0000... ;
	false.
But it is not uncommon to encounter situations where re-expressing a constraint in an mathematically equivalent form can improve performance, either reducing execution time, increasing precision, or both. Re-expressing polynomials in Horner form (see [Horner's Method]) is such a technique. Expressing the previous example in Horner form removes the spurious answer as well as sharpening the result: 
eg
	?- X::real, {1+X*(-2+X) == 0}, solve(X,8).
	X:: 1.00000... ;
	false.
The following example demonstrates the increase in performance:
eg
	?- clpStatistics,X::real,{X**4-12*X**3+47*X**2-60*X==0},solve(X),format("X = ~p\n",[X]),fail;clpStatistic(userTime(Time)).
	X = _396{real(-5.0e-324,5.0e-324)}
	X = _396{real(2.9999890861136174,3.0000110475079493)}
	X = _396{real(3.9999848619285427,4.000014629809654)}
	X = _396{real(4.999993898942933,5.0000061777287685)}
	Time = 1.068091000000095.
	% Horner is ten times faster and produces narrower results
	?- clpStatistics,X::real,{X*(-60+X*(47+X*(-12+X)))==0},solve(X),format("X = ~p\n",[X]),fail;clpStatistic(userTime(Time)). 
	X = 0.0
	X = _378{real(2.999999429349438,3.0000005619700088)}
	X = _378{real(3.999999999999966,4.000000000062313)}
	X = _378{real(4.999999476041927,5.000000543609652)}
	Time = 0.09278700000004392.
When it can be used, the Horner form is usually better but its effectiveness depends on the problems at hand. Another strategy is to identify and exploit common factors; an extreme case is expressing `X**2-2*X+1` as `(X-1)**2`:
eg
	?- {(X-1)**2==0}.
	X = 1.
but then you already knew the answer.

By applying these general mechanisms, a satisfactory solution can usually be found but different use cases may require different strategies. As is often the case in using constraints, performance can often be improved (space and/or time) by adding constraints to enhance pruning. This will be explored further in [Using Metalevel Contractors]. 

<#TableOfContents>

&
	[Using Metalevel Contractors] <- link #toc4Using_Metalevel_Contractors
	[Horner's Method] <- link https://en.wikipedia.org/wiki/Horner's_method
