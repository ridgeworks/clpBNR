#### Global Optimization

An important class of problems in engineering design and operations research is the optimal allocation of "resources", usually referred to as global optimization. Specifically it aims to find the maximum or minimum value of a function of one or more variables and to find the values of the variables where this optima is reached. Techniques for solving *local* optimization problems, i.e., solutions in the neighbourhood of a given point, have been well-researched but techniques for global optimization seem to be less well developed. One of the reasons for this is the difficulty of representing global information, but intervals can be used to address this issue. The evaluation of a function of intervals using interval arithmetic is an interval containing all the values of the function given the interval values of the arguments. Then using search techniques similar to solving for the roots of equations, a minimum/maximum value of the function, along with it's *minimizers* (the values of the arguments producing the minimum/maximum) can be found. 

Such searches can be computationally expensive, so it is often advantageous to combine it with local optimization techniques. These take the form of additional (redundant) constraints which can accelerate the searching process. In addition many global optimization problems include additional problem constraints which put further conditions on the set of solutions, so the combination of *Constraint Logic Programming* and *Relational Interval Arithmetic* seems to be a good fit for tackling this class of problems.

Material in this section draws heavily on two sources: for theory, see [New Computer Methods for Global Optimization] (Ratschek and Rokne, 2007). The examples are largely from [Schaum's Outlines, Operations Research] (Bronson and Naadimuthu,1997).

##### Unconstrained Optimization

CLP(BNR) provides a pair of general purpose predicates for tackling global optimization problems: `global_minimum` and `global_maximum`. The simplest form of these predicates finds the global min/max (the second argument, `Z`, in the examples below) for the objective function specified by the first argument. From "Shaum's" (example 10.1):
eg
	﻿?- X::real(0,20), global_maximum(X*(5*pi-X),Z).
	X:: 7.8...,
	Z:: 61.6850... .
The predicates provided use the Moore-Skelboe algorithm (see Ratschek&Rokne) to find global optima to the precision specified by the `clpBNR_default_precision` flag (default 6 digits). They do not provide the *minimisers* - indeed there may be more than one minimiser value. In the example above some narrowing of `X` has occurred but, in general, one of the solve predicates can be used to separate and sharpen minimizer values. Since there really aren't any "point solutions" to the objective function (unlike like finding roots of an equation discussed earlier), `splitsolve` is usually better suited to this problem.
eg
	?- X::real(0,20), global_maximum(X*(5*pi-X),Z), splitsolve(X).
	X:: 7.84965...,
	Z:: 61.6850... ;
	X:: 7.84966...,
	Z:: 61.6850... ;
	X:: 7.8496...,
	Z:: 61.6850... ;
	X:: 7.84967...,
	Z:: 61.6850... .
	
	﻿?- X::real(0,20), global_maximum(X*(5*pi-X),Z), solve(X).
	X:: 7.8...,
	Z:: 61.6850... ;
	false.
As we saw earlier, there may be answers for the same solution due to precision limits on the splitting process. 

For many problems, the only requirement is to find *any* solution; in fact this is often stated as a "Solution Convention". From [Schaum's Outlines, Operations Research], Chapter 1:

>	"In any mathematical program, we seek *a* solution. If a number of equally optimal solutions exist then any one will do. *There is no preference between equally optimal solutions if there is no preference stipulated in the constraints.*"

When this is all that's required, the alternative `global_minimize` and `global_maximize` will narrow the variables to the single solution generated when the min/max value for the objective is calculated, so that no separate solve step is required. 
eg
	﻿?- X::real(0,20), global_maximize(X*(5*pi-X),Z).
	X:: 7.85398...,
	Z:: 61.6850... .
All the global aptimizing predicates take an optional third argument: a precision value which overrides the current value of the `clpBNR_default_precision` flag. Use of this argument can control the tradeoff between precision and execution time (as it does for other search predicates like `solve` and `splitsolve`):
eg
	?- X::real(0,20),global_maximum(X*(5*pi-X),Z,3).
	X::real(7.715508871420747, 7.992454396528267),
	Z:: 61.7... .
These predicates are general in nature; they can find optima on boundaries (where no local optima exist) and on functions of `integer` variables. Some examples of objective functions of more than one variable:
eg
	?- [X1,X2,X3]::real,global_maximum(- (2*X1-5)**2-(X2-3)**2-(5*X3-2)**2,Z).
	X1:: 2.500...,
	X2:: 3.000...,
	X3:: 0.400...,
	Z::real(-1.8040366808093224e-7, 0).

	?- [X1,X2]::integer(-100,100),global_minimum((X1-sqrt(5))**2+(X2-pi)**2+10,Z).
	X1 = 2,
	X2 = 3,
	Z:: 10.07577656955144... .

	?- [X1,X2]::integer(-100,100),global_minimum((1-X1)**2+100*(X2-X1**2)**2,Z).
	X1 = X2, X2 = 1,
	Z = 0.

##### Constrained Optimization

Moving to CLP usually involves a paradigm shift from "generate and test" to to "apply test, then generate". This facilitates solving constrained optimization problems; just apply the constraints before calling the global optimization predicate. Some examples from "Shaum's" (chapter 12):
eg
	﻿?- {X**2+Y**2==1},global_minimum(X+Y,Z).
	X:: -0.70...,
	Y:: -0.70...,
	Z:: -1.41421... .
	
	﻿?- {X**2+Y**2==1},global_minimum(X+Y,Z),splitsolve([X,Y]).
	X:: -0.707107...,
	Y:: -0.70710...,
	Z:: -1.41421... .
	
	﻿?- {X**2+Y**2==1},global_minimize(X+Y,Z).
	X:: -0.707107...,
	Y:: -0.707106...,
	Z:: -1.41421... .
	
	?- [X1,X2,X3]::real(0,2*pi), {-X1*X2**3+X1**2*X3**2==5}, global_maximum(sin(X1*X2+X3),Z),splitsolve([X1,X2,X3]).
	X1:: 1.49453...,
	X2:: 0.049262...,
	X3:: 1.49619...,
	Z:: 0.99999951... .
	
	﻿?- [X1,X2,X3]::integer,{X1+2*X2+3*X3==4,X1*X3==19}, global_maximum(-X1**6*X2**2-X1**4*X3**2-1,Z),splitsolve([X1,X2,X3]).
	X1 = 1,
	X2 = -27,
	X3 = 19,
	Z = -1091.
	
	﻿?- [X1,X2]::real(_,_),{X1+X2=<2}, global_maximum(log(1+X1)+2*log(1+X2),Z),splitsolve([X1,X2]).
	X1:: 0.333333...,
	X2:: 1.666666...,
	Z:: 2.249340... .
	
	﻿?- [X1,X2]::real(0,_),{X1+2*X2=<3,8*X1+5*X2>=10}, global_minimum((X1-2)**2+(X2-2)**2,Z),splitsolve([X1,X2]).
	﻿X1:: 1.399230...,
	X2:: 0.800384...,
	Z:: 1.800000... .
Most of these examples generate answers fairly quickly, but it's not hard to come up with examples that take a long time and millions of narrowing operations. Constraining the search space and using the tunable precision flag can help to produce acceptable answers in a reasonable time frame. And mixing local optimization techniques with global searches can result in sharper answers in less time as we'll see later.

##### The Knapsack Problem

The [Knapsack Problem] is a well researched problem in combinatorial optimization with many real world applications. It derives its name the problem of maximizing the value of items placed in a fixed-size knapsack. The example in the reference Wikipedia article describes a knapsack that can carry 15 kg. to be filled with coloured boxes with the following properties:
.tsv
	Colour		Weight(kg.)		Value
	Green		`12`			` 4`
	Grey		` 1`			` 2`
	Yellow		` 4`			`10`
	Orange		` 1`			` 1`
	Blue		` 2`			` 2`
First consider the case where there is only one box of each type:
eg
	﻿?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,1),
	{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	global_maximum(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,Take).
	Boxes = [0, 1, 1, 1, 1],
	Green = 0,
	Grey = Yellow, Yellow = Orange, Orange = Blue, Blue = 1,
	Take = 15.
In this case taking every box but the Green provides maximum value (15) even though the total weight is only 8 kg. Also note that the minimizer values are generated without an extra solve step.

Now consider the case where there is an unlimited supply of each coloured box:
eg
	﻿?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,_),
	{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	global_maximum(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,Take).
	Boxes = [Green, Grey, Yellow, Orange, Blue],
	Take = 36,
	Green::boolean,
	Grey::integer(0, 15),
	Yellow::integer(0, 3),
	Orange::integer(0, 15),
	Blue::integer(0, 7).
	
	﻿?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,_),
	{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	global_maximize(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,Take).
	Boxes = [0, 3, 3, 0, 0],
	Green = Orange, Orange = Blue, Blue = 0,
	Grey = Yellow, Yellow = 3,
	Take = 36.
	
	?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,_),
	{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	global_maximum(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,Take), splitsolve(Boxes).
	Boxes = [0, 3, 3, 0, 0],
	Green = Orange, Orange = Blue, Blue = 0,
	Grey = Yellow, Yellow = 3,
	Take = 36 ;
	false.
In this case the (only) optimal solution is to take 3 each of the Grey and Yellow boxes for a total value of 36 and an enumeration step (`splitsolve` or `enumerate`) is necessary to produce the minimizer values.

A variation on this simple knapsack problems is the multi-constraint problem, e.g., if the knapsack was constrained by volume in addition to weight. These can be simpley addressed by adding the additional constraints to the `{}` constraint term as can be seen in the following examples from Schaum's.
 
##### The Furniture Maker
"*A furniture maker has 6 units of wood and 28 h of free time, in which he will make decorative screens. Two models have sold well in the past, so he will restrict himself to those two. He estimates that model I requires 2 units of wood and 7 h of time, while model II requires 1 unit of wood and 8 h of time.  The prices of the models are $120 and $80 respectively. How many screens of each model should the furniture maker assemble if he wishes to maximize his sales revenue?*"

This integer problem can be easily expressed in CLP(BNR):
eg
	﻿?- [M_1,M_2]::integer(0,_), {2*M_1+M_2=<6, 7*M_1+8*M_2=<28}, global_maximum(120*M_1+80*M_2, Revenue).
	M_1 = 3,
	M_2 = 0,
	Revenue = 360.
Maximum revenue of $360 can be achieved by building 3 model I screens and no model II's.

##### "Universal Mines Inc."
"*Universal Mines Inc. operates three mines in West Virginia. The ore from each mine is separated into two grades before it is shipped; the daily production capacities of the mines, as well as their daily operating costs, are as follows:*
.tsv
	 		High-grade Ore, tons/day	Low-grade Ore, tons/day	Operating Cost, $1000/day
	Mine I			4							4						20
	Mine II			6							4						22
	Mine III		1							6						18
*Universal has committed itself to deliver 54 tons of high-grade ore and 65 tons of low-grade ore by the end of the week. It also has labor contracts that guarantee employees in each mine a full day’s pay for each day or fraction of a day the mine is open. Determine the number of days each mine should be operated during the upcoming week if Universal Mines is to fulfill its commitment at minimum total cost.*
 
*Hidden constraints: No mine may operate a negative number of days and no mine may operate more than 7 days in a week. In view of the labor contracts, Universal Mines has nothing to gain in operating a mine for part of a day.*"

The hidden constraints bound the days for each mine to `integer(0,7)`:
eg
	﻿?- [M_Idays,M_IIdays,M_IIIdays]::integer(0,7), Cost::integer(0,_),
	{4*M_Idays+6*M_IIdays+M_IIIdays >= 54, 4*M_Idays+4*M_IIdays+6*M_IIIdays >= 65}, 
	global_minimum(20*M_Idays+22*M_IIdays+18*M_IIIdays, Cost), splitsolve([M_Idays,M_IIdays,M_IIIdays]).
	M_Idays = 2,
	M_IIdays = 7,
	M_IIIdays = 5,
	Cost = 284 ;
	false.
Minimum cost (single solution) to achieve target production is $284,000 running Mine I for 2 days, Mine II for 7 days, and Mine 3 for 5 days.

##### The Investor
"*An individual has $4000 to invest and three opportunities available to him. Each opportunity requires deposits in $1000 amounts; the investor may allocate all the money to just one opportunity or split the money between them. The expected returns are tabulated as follows:*
.tsv
	Dollars Invested:		0	1000	2000	3000	4000
	Return Opportunity 1	0	2000	5000	6000	7000
	Return Opportunity 2	0	1000	3000	6000	7000
	Return Opportunity 3	0	1000	4000	5000	8000
*How much money should be invested in each opportunity to obtain the greatest total return?*"

The returns are not simple functions of dollars invested, but can be expressed by boolean expressions to separate the various cases:
eg
	﻿?- [Op1,Op2,Op3]::integer(0,4), {Op1+Op2+Op3 =< 4},
	global_maximize((Op1==1)*2 + (Op1>1)*(Op1+3) +
	 (Op2==1) + (Op2==2)*3 + (Op2>2)*(Op2+3) +
	 (Op3==1) + (Op3==2)*4 + (Op3==3)*5 +(Op3==4)*8, Return).
	Op1 = Op3, Op3 = 2,
	Op2 = 0,
	Return = 9.
The maximum return can be be realized by investing $2000 in each of opportunity 1 and opportunity 3.

##### "Aztec Refining Company"
"*The Aztec Refining Company produces two types of unleaded gasoline, regular and premium, which it sells to its chain of service stations for $12 and $14 per barrel, respectively. Both types are blended from Aztec’s inventory of refined domestic oil and refined foreign oil, and must meet the following specifications:*
.tsv
	 	Maximum Vapor Pressure	Minimum Octane Rating	Maximum Demand, bbl/wk	Minimum Deliveries, bbl/wk
	Regular		23						88						100000					50000
	Premium		15						98						20000					5000
*The characteristics of the refined oils in inventory are as follows:*
.tsv
	 	Vapor Pressure	Octane Rating	Inventory, bbl	Cost, $/bbl
	Domestic	25			87				40000			8
	Foreign		15			98				60000			15
*What quantities of the two oils should Aztec blend into the two gasolines in order to maximize weekly profit?*"

If:
>	`RegDom` = barrels of domestic blended into regular
	`RegFor` = barrels of foreign blended into regular
	`PremDom` = barrels of domestic blended into premium
	`PremFor` = barrels of foreign blended into premium
then `Profit` is revenue from sales of regular and premium gas minus the cost of of foreign and domestics oil used it the production:
>	`Profit = 12*(RegDom+RegFor) + 14*(PremDom+PremFor) - 8*(RegDom+PremDom) - 15*(RegFor+PremFor)`
	`       = 4*RegDom - 3*RegFor + 6*PremDom - PremFor`
Additional constraints are imposed by the demand and available inventory:
>	`RegDom+RegFor =< 100000` (maximum demand for regular)
	`RegDom+RegFor >= 50000` (minimum regular required)
	`PremDom+PremFor =< 20000` (maximum demand for premium)
	`PremDom+PremFor >= 5000` (minimum premium required)
	`RegDom+PremDom =< 40000` (domestic)
	`RegFor+PremFor =< 60000` (foreign)
And finally, the constituents of a blend contribute to the overall octane rating according to their percentages by weight; likewise for the vapor pressure:
>	`10*RegFor-RegDom >= 0` (regular octane constraint: ((87xRegDom)+(98xRegFor))/(RegDom+RegFor) >= 88 )
	`5*PremFor-6*PremDom >= 0` (premium octane constraint)
	`2*RegDom-8*RegFor =< 0` (regular vapor pressure constraint: ((25xRegDom)+(15xRegFor))/(RegDom+RegFor) =< 23 )
	`2*PremDom-8*PremFor =< 0` (premium vapor pressure constraint)
Just calculating the maximum profit to 3 decimal places still takes several seconds:
eg
	﻿?- [RegDom,RegFor,PremDom,PremFor]::real(0,_), OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	{
	RegDom+RegFor=<100000, RegDom+RegFor>=50000, PremDom+PremFor=<20000, PremDom+PremFor>=5000,
	RegDom+PremDom=<40000, RegFor+PremFor=<60000,
	10*RegFor-RegDom>=0, 5*PremFor-6*PremDom>=0, 2*RegDom-8*RegFor=<0, 2*PremDom-8*PremFor=<0
	},
	global_maximum(OF,Profit,3),
	{Regular==RegDom+RegFor, Premium==PremDom+PremFor, Domestic==RegDom+PremDom, Foreign==RegFor+PremFor}.
	OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	RegDom::real(13735.04638671875, 40000),
	RegFor::real(10000, 45019.938151041664),
	PremDom::real(0, 16666.666666666668),
	PremFor::real(0, 20000),
	Profit::real(124940.185546875, 125059.814453125),
	Regular::real(23735.04638671875, 85019.93815104167),
	Premium::real(0, 36666.666666666664),
	Domestic::real(13735.04638671875, 56666.666666666664),
	Foreign::real(10000, 65019.938151041664).
The profit is in the neighbourhood of $125,000, but to calculate the amounts of each oil type to use and each type of gasoline to produce, the minimizers must be calculated. This can be done by using the generated single solution produced by `global_minimize` or by using one of the solve predicates, in this case `splitsolve`:
eg
	﻿?- [RegDom,RegFor,PremDom,PremFor]::real(0,_), OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	{
	RegDom+RegFor=<100000, RegDom+RegFor>=50000, PremDom+PremFor=<20000, PremDom+PremFor>=5000,
	RegDom+PremDom=<40000, RegFor+PremFor=<60000,
	10*RegFor-RegDom>=0, 5*PremFor-6*PremDom>=0, 2*RegDom-8*RegFor=<0, 2*PremDom-8*PremFor=<0
	},
	global_maximize(OF,Profit,3), 
	{Regular==RegDom+RegFor, Premium==PremDom+PremFor, Domestic==RegDom+PremDom, Foreign==RegFor+PremFor}.
	OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	RegDom::real(37730.712890625, 37739.2578125),
	RegFor::real(12260.7421875, 12269.287109375),
	PremDom::real(2260.7421875, 2269.287109375),
	PremFor::real(2730.712890625, 2739.2578125),
	Profit::real(124940.185546875, 125059.814453125),
	Regular::real(49991.455078125, 50008.544921875),
	Premium::real(4991.455078125, 5008.544921875),
	Domestic::real(39991.455078125, 40008.544921875),
	Foreign::real(14991.455078125, 15008.544921875).
	
	﻿?- [RegDom,RegFor,PremDom,PremFor]::real(0,_), OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	{
	RegDom+RegFor=<100000, RegDom+RegFor>=50000, PremDom+PremFor=<20000, PremDom+PremFor>=5000,
	RegDom+PremDom=<40000, RegFor+PremFor=<60000,
	10*RegFor-RegDom>=0, 5*PremFor-6*PremDom>=0, 2*RegDom-8*RegFor=<0, 2*PremDom-8*PremFor=<0
	},
	global_maximum(OF,Profit,3), splitsolve([RegDom,RegFor,PremDom,PremFor]),
	{Regular==RegDom+RegFor, Premium==PremDom+PremFor, Domestic==RegDom+PremDom, Foreign==RegFor+PremFor}.
	OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	RegDom:: 37712.62...,
	RegFor:: 12287.3...,
	PremDom:: 2281.62...,
	PremFor:: 2737.95...,
	Profit:: 124940.2...,
	Regular:: 50000.0...,
	Premium:: 5019.5...,
	Domestic:: 39994.2...,
	Foreign:: 15025.3... .
In this case using `splitsolve` is of dubious value since there are very many possible answers given the wide domain of `Profit`. Due to order of the search used by `splitsolve`, a solution at the low end of the profit range is generated: produce 50,000 barrels of regular and ~5020 barrels of premium gas using ~39994 barrels of domestic and ~15025 barrels of foreign oil.

This is quite close to the precise answer for this problem, a profit of $125,000 (50,000 regular and 5,000 premium barrels using 40,000 domestic and 15000 foreign barrels). If necessary, one way of "sharpening" the answer is to increase the precision value argument to `global_maximum` at the expense of longer calculation time:
eg
	﻿?- [RegDom,RegFor,PremDom,PremFor]::real(0,_), OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	{
	RegDom+RegFor=<100000, RegDom+RegFor>=50000, PremDom+PremFor=<20000, PremDom+PremFor>=5000,
	RegDom+PremDom=<40000, RegFor+PremFor=<60000,
	10*RegFor-RegDom>=0, 5*PremFor-6*PremDom>=0, 2*RegDom-8*RegFor=<0, 2*PremDom-8*PremFor=<0
	},
	global_maximize(OF,Profit,4),
	{Regular==RegDom+RegFor, Premium==PremDom+PremFor, Domestic==RegDom+PremDom, Foreign==RegFor+PremFor}.
	OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	RegDom::real(39999.237060546875, 40000),
	RegFor::real(10000, 10000.762939453125),
	PremDom::real(0, 0.762939453125),
	PremFor::real(4999.237060546875, 5000),
	Profit::real(124994.65942382812, 125005.34057617188),
	Regular::real(49999.237060546875, 50000.762939453125),
	Premium::real(4999.237060546875, 5000.762939453125),
	Domestic::real(39999.237060546875, 40000.762939453125),
	Foreign::real(14999.237060546875, 15000.762939453125).
But this is a fair amount of additional work for not much gain (for this particular problem). A different approach to generating better results in less time is discussed below.

##### Optimizing Linear Systems

Predicates `global_maximum` and `global_minimum` are implemented as directed branch-and-bound searches. They can be used for almost any problem but for linear systems there exist algorithms which can calculate optima directly and will usually be much more efficient than searching for solutions. (This is analogous to using Cramer's rule for solving a set of linear equations as discussed previously.) `library(simplex)` which is contained in the distributed SWI-Prolog library provides such an algorithm for optimization of linear systems but the API is somewhat foreign from the perspective of CLP's. Module `clpBNR_toolkit`, distributed with `clpBNR`, provides a "friendlier" API for `clpBNR` users in the form of `lin_minimum/3` and `lin_maximum/3`.

`lin_minimum/3` and `lin_maximum/3`'s arguments are an objective expression `ObjF` to be min/maximized, a set of constraints, `{Constraints}`, as expressed in `clpBNR` notation, and unifies the third argument, `OptValue`, with max/minimum value of the objective expression subject to those constraints. Like `global_maximum` and `global_minimum` they do not narrow any contained variables to the maximizer/minimizer values; these can be generated by a subsequent labelling step using `splitsolve` for example. However, a constraint is applied equating the calculated value with the objective expression (i.e., `{ObjF==OptValue}`). Also all constraints are also applied, so this doesn't have to be done beforehand (as when using the global optimizing predicates in module `clpBNR`.

"The Furniture Maker" example:
eg
	?- [M_1,M_2]::integer, lin_maximum(120*M_1+80*M_2,{2*M_1+M_2=<6,7*M_1+8*M_2=<28},Revenue).
	M_1 = 3,
	M_2 = 0,
	Revenue = 360.
Since `library(simplex)` is specifically for linear systems, there are limitations placed on the objective expression and the constraints. Specifically, the expression and the right hand side of the constraints must be "linear", i.e., a sum of terms of the form `Number*Var` (or `Var*Number`). The relational operator  in the constraint must be one of `=<`, `>=`, or `==`, and the left hand side of the constraint must be a positive number. All variables must be non-negative, and will be constrained to be so if not already. 

"The Knapsack Problem" using `lin_maximum/3`:
eg
	﻿?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,_),
	lin_maximum(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	Take).
	Boxes = [Green, Grey, Yellow, Orange, Blue],
	Take = 36,
	Green::boolean,
	Grey::integer(0, 15),
	Yellow::integer(0, 3),
	Orange::integer(0, 15),
	Blue::integer(0, 7).
	
	?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,_),
	lin_maximum(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	Take),splitsolve(Boxes).
	Boxes = [0, 3, 3, 0, 0],
	Green = Orange, Orange = Blue, Blue = 0,
	Grey = Yellow, Yellow = 3,
	Take = 36 ;
	false.

The "Universal Mines Inc." example:
eg
	?- [M_Idays,M_IIdays,M_IIIdays]::integer(0,7),
	lin_minimum(20*M_Idays+22*M_IIdays+18*M_IIIdays,
	{4*M_Idays+6*M_IIdays+M_IIIdays>=54,4*M_Idays+4*M_IIdays+6*M_IIIdays>=65},
	Min).
	Min = 284,
	M_Idays::integer(2, 7),
	M_IIdays::integer(4, 7),
	M_IIIdays::integer(2, 7).
	
	?- [M_Idays,M_IIdays,M_IIIdays]::integer(0,7),
	lin_minimum(20*M_Idays+22*M_IIdays+18*M_IIIdays,
	{4*M_Idays+6*M_IIdays+M_IIIdays>=54,4*M_Idays+4*M_IIdays+6*M_IIIdays>=65},
	Min),splitsolve([M_Idays,M_IIdays,M_IIIdays]).
	M_Idays = 2,
	M_IIdays = 7,
	M_IIIdays = 5,
	Min = 284 ;
	false.
The second query in the previous two examples uses `splitsolve` to generate all solutions; in each case there is only one. As discussed previously, it is often the case that the only requirement is to find *any* solution. `library(simplex)` does calculate a set of min/maximizer values corresponding to the optimal objective requested. Predicates `lin_minimize/3` and `lin_maximize/3` will bind any variables to the calculated values so there is no need to use a labelling predicate to do so. This is the most efficient way to calculate a complete solution for linear optimization problems. Using previous examples:
eg

	﻿?- [M_Idays,M_IIdays,M_IIIdays]::integer(0,7),lin_minimize(20*M_Idays+22*M_IIdays+18*M_IIIdays,{4*M_Idays+6*M_IIdays+M_IIIdays>=54,4*M_Idays+4*M_IIdays+6*M_IIIdays>=65},Min).
	M_Idays = 2,
	M_IIdays = 7,
	M_IIIdays = 5,
	Min = 284.
	
	﻿?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,_),
	lin_maximize(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	Take).
	Boxes = [0, 3, 3, 0, 0],
	Green = Orange, Orange = Blue, Blue = 0,
	Grey = Yellow, Yellow = 3,
	Take = 36.
	
	﻿?- [RegDom,RegFor,PremDom,PremFor]::real, 
	lin_maximize(4*RegDom-3*RegFor+6*PremDom-PremFor,
	{RegDom+RegFor=<100000, RegDom+RegFor>=50000, PremDom+PremFor=<20000, PremDom+PremFor>=5000,
	RegDom+PremDom=<40000, RegFor+PremFor=<60000,  
	10*RegFor-RegDom>=0, 5*PremFor-6*PremDom>=0, 2*RegDom-8*RegFor=<0, 2*PremDom-8*PremFor=<0},
	Max), RegDomF is float(RegDom), RegForF is float(RegFor), PremDomF is float(PremDom), PremForF is float(PremFor).
	RegDom = 415000r11,
	RegFor = 135000r11,
	PremDom = 25000r11,
	PremFor = 30000r11,
	Max = 125000,
	RegDomF = 37727.27272727273,
	RegForF = 12272.727272727272,
	PremDomF = 2272.7272727272725,
	PremForF = 2727.2727272727275.
The last example demonstrates an important feature of `library(simplex)`, namely that it uses rational arithmetic to avoid the unsound properties of floating point arithmetic. Any floating point constants in the objective expression or constraints are treated as precise values and converted to rational numbers before any calculations are done. This remains safe as long as the rational numbers do not exceed the `max_rational_size` value (a SWI-Prolog environment flag - also see section 4.27.2 of [[SWIP Manual - Arithmetic]]). Unfortunately, the rational results can be hard to interpret so this example also generates the (approximate) floating point equivalents.

As an extreme example consider "[The Stigler Diet Problem]" which has 9 linear constraints in 77 variables. Applying a bifurcating search like `splitsolve` or `enumerate` on 77 variables is impractical but `lin_minimize` produces the documented solution (there may be more?) in approximately 1 second. 

Many optimization problems can be modelled as a linear system so it's worthwhile having special purpose tools within a CLP framework to tackle these kinds of problems. For non-linear problems, see the next section.

##### Redundant Constraints using Local Optimization 

Earlier sections described using common numerical techniques to rewrite or create redundant constraints to improve answers and reduce execution times. These techniques can be applied because the underlying arithmetic system is mathematically sound so there can be confidence in the answers produced - rounding errors may result in "wider" answers but should never produce wrong answers.

For non-linear problems, if the assumption can be made that global optima are also local optima, and the objective function and constraints have certain properties, additional constraints can be defined which generally result in better answers in less time. (This isn't always the case since additional time is required to check the additional constraints which may not always result in a pruning of the search space.) For unconstrained optimization, this takes the form of constraining the gradient to be zero at the local optima. For constrained optimizations involving equalities and inequalities, techniques involving Lagrangian functions and [Karush–Kuhn–Tucker] conditions can be used. These will not be described in detail in this document, but information can be readily found in any text on solving local optimization problems.
 
The local optimization technique described requires that the objective function and all constraints must be continuously differentiable over the range of all variables of interest. This precludes functions such as `max` and `abs`. In general, functions of `integer` intervals cannot be used because local optima are not necessarily found at integral values.

The accompanying `clpBNR_toolkit` module exports a couple of predicates to apply local minima and maxima constraints to constrained and unconstrained optimization problems. For unconstrained problems use `local_minima(ObjExp)` and `local_minima(ObjExp)`; for constrained optimization use `local_minima(ObjExp,{Constraints})` and `local_minima(ObjExp,{Constraints})`. Note that these do not generate any minimum or maximum values; they jsut apply the additional contraints that will be applied when `global_minimum` or `global_maximum` is called. For this reason, `local_minima` should be paired with `global_minimum` and `local_maxima` with `global_maximum`.

`local_minima/2` and `local_maxima/2` also apply the `{Constraints}` so there is no need to do this separately.

A simple example of unconstrained optimization with and without local optima constraints:
eg
	?- X::real(0,20), global_maximum(X*(5*pi-X),Z).
	 X:: 7.8...,
	 Z:: 61.6850... .
	 
	?- X::real(0,20), global_maximum(X*(5*pi-X),Z),splitsolve(X).
	X:: 7.84965...,
	Z:: 61.6850... .
	
	﻿?- X::real(0,20), OF=X*(5*pi-X), local_maxima(OF), global_maximum(OF,Z).
	OF = X*(5*pi-X),
	X:: 7.85398163397448...,
	Z:: 61.685027506808... ;
	false.
Note that the additional constraints produce a much sharper answer in much less time (orders of magnitude for this simple example). And the search finds the single solution without requiring the use of solve to find the minimizer.

Other examples:
eg
	﻿?- [X1,X2]::real,OF=log(1+X1)+2*log(1+X2), local_maxima(OF,{X1+X2=<2}),global_maximum(OF,Z).
	OF = log(1+X1)+2*log(1+X2),
	X1:: 0.33333333333333...,
	X2:: 1.66666666666666...,
	Z:: 2.24934057847523... .

	﻿?- [X1,X2]::real, OF=(X1-2)**2+(X2-2)**2, local_minima(OF,{X1+2*X2=<3,8*X1+5*X2>=10}),global_minimum(OF,Z).
	OF =  (X1-2)**2+(X2-2)**2,
	X1:: 1.400000000000000...,
	X2:: 0.800000000000000...,
	Z:: 1.80000000000000... ;
	false.
Again much sharper answers in much less time. In general, it's advantageous to use `local_minima` and `local_maxima` but this requires that a local critical point exists within the domain defined by the problem. If such is not the case the search may fail, i.e. the global optima is at a boundary. In this case, it make take an excessive amount of time and/or stack space to find it by exhaustive search. A couple of other non-linear optimization examples follow.

##### "Cheese Shop"
"*A cheese shop has 20 lb of a seasonal fruit mix and 60 lb of an expensive cheese with which it will make two cheese spreads, delux and regular, that are popular during Christmas week. Each pound of the delux spread consists of 0.2 lb of the fruit mix and 0.8 lb of the expensive cheese, while each pound of the regular spread consists of 0.2 lb of the fruit mix, 0.3 lb of the expensive cheese, and 0.5 lb of a filler cheese which is cheap and in plentiful supply. From past pricing policies, the shop has found that the demand for each spread depends on its price as follows:*
>	`Dd = 190 - 25*Pd`  and  `Dr = 250 - 50*Pr`
*where `D` denotes demand (in pounds), `P` denotes price (in dollars per pound), and the subscripts `d` and `r` refer to the delux and regular spreads, respectively. How many pounds of each spread should the cheese shop prepare, and what prices should it establish, if it wishes to maximize income and be left with no inventory of either spread at the end of Christmas week?*"

If `X` denotes the amount of each spread to be made. the objective is to maximize `Pd*Xd_Pr*Xr`. To eliminate excess inventory, production must not exceed demand, i.e., `Xd=<Dd` and `Xr=<Dr`. Fom the availability of the raw ingredients, `0.2*X1+0.2*X2=<20` and `0.8*X1+0.3*X2=<60`. The solution is given by:
eg
	﻿?- [Xd,Xr,Pd,Pr]::real(0,_), OF=Pd*Xd+Pr*Xr,
	local_maxima(OF,{0.2*Xd+0.2*Xr=<20, 0.8*Xd+0.3*Xr=<60, Xd=<190-25*Pd, Xr=<250-50*Pr}),
	global_maximum(OF,Income), splitsolve([Xd,Xr,Pd,Pr]).
	OF = Pd*Xd+Pr*Xr,
	Xd:: 55.00000...,
	Xr:: 45.00000...,
	Pd:: 5.4000000...,
	Pr:: 4.1000000...,
	Income:: 481.50000000000... ;
	false.
The maximum income of $481.50 can be realized by making (and selling) 55 pounds of deluxe spread at $5.50/pound, and 45 pounds of of regular at $4.10/pound. (This example runs over 50 times faster with local optima constraints applied.)

##### Refinery Location
"*A major oil company wants to build a refinery that will be supplied from three port cities. Port B is located 300 km east and 400 km north of Port A, while Port C is 400 km east and 100 km south of Port B. Determine the location of the refinery so that the total amount of pipe required to connect the refinery to the ports is minimized.*"

The objective is to minimize the distance between the refinery and the three ports. Assuming a coordinate system with Port A at ` (0,0) ` the objective function becomes:
>	`sqrt(X**2+Y**2)+sqrt((X-300)**2+(Y-400)**2)+sqrt((X-700)**2+(Y-300)**2)`
where the refinery is located at `(X,Y)`. A (redundant) constraint to minimize the search space is that the refinery must lie within the box bounded by the ports, which imposes an upper bound on `X` of 700, and on `Y` of 400. This is an unconstrained global optimization which will just use simple gradient constraints:
eg
	﻿?- X::real(0,700),Y::real(0,400),
	OF = sqrt(X**2+Y**2)+sqrt((X-300.0)**2+(Y-400.0)**2)+sqrt((X-700.0)**2+(Y-300.0)**2),
	local_minima(OF), global_minimize(OF,Pipe).
	OF = sqrt(X**2+Y**2)+sqrt((X-300.0)**2+(Y-400.0)**2)+sqrt((X-700.0)**2+(Y-300.0)**2),
	X:: 311.096...,
	Y:: 369.331...,
	Pipe:: 910.543... .

##### Caveats

The number of global, local, and linear optimization predicates, in combination with the labelling predicates (`solve` and friends) are provided because when it comes to optimization probles, not one size fits all. The general techniques are deceptively simple and declarative. However, one must remember that they are based on exhaustive search which can be very expensive. When the problem allows, alternative techniques, e.g., as supported by `library(simplex)` for linear problems, should be used. When this can't be done, applying hidden and redundant constraints can result in a significant improvement, as will any reduction in the precision requirements (third argument of `global_max...` and `global_min...`). 

A second issue is that the objective function passed to global optimum predicates must contain sufficient free values (intervals) so that solutions can be fully tested. Consider the following simple change to the "Refinery Location" example:
eg
	﻿?- X::real(0,700),Y::real(0,400),
	OF = sqrt(X**2+Y**2)+sqrt((X-300.0)**2+(Y-400.0)**2)+sqrt((X-700.0)**2+(Y-300.0)**2),
	local_minima(OF), {OF==Z}, global_minimize(Z,Pipe).
	OF = sqrt(X**2+Y**2)+sqrt((X-300.0)**2+(Y-400.0)**2)+sqrt((X-700.0)**2+(Y-300.0)**2),
	Z = Pipe,
	X::real(253.31280547966463, 478.29843889534044),
	Y::real(191.61042849565473, 400),
	Pipe:: 692.769... .
Here `{OF==Z}` has been applied before calling `global_minimize` which now only has `Z` and its constraints to use. Searching for a minima using only `Z` is problematic because full narrowing is only possible when there is no dependancy problem, which is often not the case. In this example, an invalid minimum has been reached. If `solve` is used to furether constrain `X` and `Y`, it will fail:
eg
	﻿?- X::real(0,700),Y::real(0,400),
	OF = sqrt(X**2+Y**2)+sqrt((X-300.0)**2+(Y-400.0)**2)+sqrt((X-700.0)**2+(Y-300.0)**2),
	local_minima(OF), {OF==Z}, global_minimize(Z,Pipe), solve([X,Y]).
	false.
When there is insufficient correlation between the objective function and the set of constrained variables, a custom "branch and bound" technique is necessary.

Global optimization is a hard problem and the tools described in this section are not the only way to tackle it. Alternative searching techniques and numerical methods can be applied which can be more effective in particular problem domains. Domain specific constraints which may be hidden in the original problem statement should almost always be used to prune what can be a very large search space.

<#TableOfContents>

&
	[New Computer Methods for Global Optimization] <- link https://pages.cpsc.ucalgary.ca/~rokne/global_book.pdf
	[Schaum's Outlines, Operations Research] <- link https://www.amazon.com/gp/product/B00AUGCJD0/ref=dbs_a_def_rwt_bibl_vppi_i1
	[Karush–Kuhn–Tucker] <- link https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions
	[Knapsack Problem] <- link https://en.wikipedia.org/wiki/Knapsack_problem
	[[SWIP Manual - Arithmetic]] <- link https://www.swi-prolog.org/pldoc/man?section=arith
	[The Stigler Diet Problem] <- link https://developers.google.com/optimization/lp/stigler_diet