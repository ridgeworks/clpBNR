#### Global Optimization

An important class of problems in engineering design and operations research is the optimal allocation of "resources", usually referred to as global optimization. Specifically it aims to find the maximum or minimum value of a function of one or more variables and to find the values of the variables where this optima is reached. Techniques for solving *local* optimization problems, i.e., solutions in the neighbourhood of a given point, have been well-researched but techniques for global optimization seem to be less well developed. One of the reasons for this is the difficulty of representing global information, but intervals can be used to address this issue. The evaluation of a function of intervals using interval arithmetic is an interval containing all the values of the function given the interval values of the arguments. Then using search techniques similar to solving for the roots of equations, a minimum/maximum value of the function, along with it's *minimizers* (the values of the arguments producing the minimum/maximum) can be found. 

Such searches can be computationally expensive, so it is often advantageous to combine it with local optimization techniques. These take the form of additional (redundant) constraints which can accelerate the searching process. In addition many global optimization problems include additional problem constraints which put further conditions on the set of solutions, so the combination of *Constraint Logic Programming* and *Relational Interval Arithmetic* seems to be a good fit for tackling this class of problems.

Material in this section draws heavily on two sources: for theory, see [New Computer Methods for Global Optimization] (Ratschek and Rokne, 2007). The examples are largely from [Schaum's Outlines, Operations Research] (Bronson and Naadimuthu,1997).

##### Unconstrained Optimization

CLP(BNR) provides a pair of general purpose predicates for tackling global optimization problems: `global_minimum` and `global_maximum`. The simplest form of these predicates finds the global min/max (the second argument, `Z`, in the examples below) for the objective function specified by the first argument. From "Shaum's" (example 10.1):
eg
	﻿?- X::real(0,20), global_maximum(X*(5*pi-X),Z).
	X:: 7.8...,
	Z:: 61.6850... .
The predicates provided use the Moore-Skelboe algorithm (see [New Computer Methods for Global Optimization]) to find global optima to the precision specified by the `clpBNR_default_precision` flag (default 6 digits). They do not provide the *minimisers* - indeed there may be more than one set of minimiser values. In the example above some narrowing of `X` has occurred but, in general, one of the solve predicates can be used to separate and sharpen minimizer values. Since there really aren't any "point solutions" to the objective function (unlike like finding roots of an equation discussed earlier), `splitsolve` is usually better suited to this problem.
eg
	?- X::real(0,20), global_maximum(X*(5*pi-X),Z), splitsolve(X).
	X:: 7.84965...,
	Z:: 61.6850... ;
	X:: 7.84966...,
	Z:: 61.6850... ;
	X:: 7.8496...,
	Z:: 61.6850... ;
	X:: 7.84967...,
	Z:: 61.6850... .
	
	?- X::real(0,20), global_maximum(X*(5*pi-X),Z), solve(X).
	X:: 7.8...,
	Z:: 61.6850... ;
	false.
As we saw earlier, there may be answers for the same solution due to precision limits on the splitting process. 

For many problems, the only requirement is to find *any* solution; in fact this is often stated as a "Solution Convention". From [Schaum's Outlines, Operations Research], Chapter 1:

>	"In any mathematical program, we seek *a* solution. If a number of equally optimal solutions exist then any one will do. *There is no preference between equally optimal solutions if there is no preference stipulated in the constraints.*"

When this is all that's required, the alternative `global_minimize` and `global_maximize` will narrow the variables to the single solution generated when the min/max value for the objective is calculated, so that no separate solve step is required. 
eg
	﻿?- X::real(0,20), global_maximize(X*(5*pi-X),Z).
	X:: 7.85398...,
	Z:: 61.6850... .
All the global aptimizing predicates take an optional third argument: a precision value which overrides the current value of the `clpBNR_default_precision` flag. Use of this argument can control the tradeoff between precision and execution time (as it does for other search predicates like `solve` and `splitsolve`):
eg
	?- X::real(0,20),global_maximum(X*(5*pi-X),Z,3).
	X::real(7.715508871420848, 7.992454396528164),
	Z:: 61.7... .
These predicates are general in nature; they can find optima on boundaries (where no local optima exist) and on functions of `integer` variables. Some examples of objective functions of more than one variable:
eg
	?- [X1,X2,X3]::real,global_maximum(- (2*X1-5)**2-(X2-3)**2-(5*X3-2)**2,Z).
	X1:: 2.500...,
	X2:: 3.000...,
	X3:: 0.400...,
	Z::real(-1.8040366808093224e-7, 0).

	?- [X1,X2]::integer(-100,100),global_minimum((X1-sqrt(5))**2+(X2-pi)**2+10,Z).
	X1 = 2,
	X2 = 3,
	Z:: 10.07577656955144... .

	?- [X1,X2]::integer(-100,100),global_minimum((1-X1)**2+100*(X2-X1**2)**2,Z).
	X1 = X2, X2 = 1,
	Z = 0.

##### Constrained Optimization

Moving to CLP usually involves a paradigm shift from "generate and test" to to "apply test, then generate". This facilitates solving constrained optimization problems; just apply the constraints before calling the global optimization predicate. Some examples from "Schaum's" (chapter 12):
eg
	﻿?- {X**2+Y**2==1},global_minimum(X+Y,Z).
	X:: -0.70...,
	Y:: -0.70...,
	Z:: -1.41421... .
	
	﻿?- {X**2+Y**2==1},global_minimum(X+Y,Z),splitsolve([X,Y]).
	X:: -0.707107...,
	Y:: -0.70710...,
	Z:: -1.41421... .
	
	﻿?- {X**2+Y**2==1},global_minimize(X+Y,Z).
	X:: -0.707107...,
	Y:: -0.707106...,
	Z:: -1.41421... .
	
	?- [X1,X2,X3]::real(0,2*pi), {-X1*X2**3+X1**2*X3**2==5}, global_maximum(sin(X1*X2+X3),Z),splitsolve([X1,X2,X3]).
	X1:: 1.49453...,
	X2:: 0.049262...,
	X3:: 1.49619...,
	Z:: 0.99999951... .
	
	﻿?- [X1,X2,X3]::integer,{X1+2*X2+3*X3==4,X1*X3==19}, global_maximum(-X1**6*X2**2-X1**4*X3**2-1,Z),splitsolve([X1,X2,X3]).
	X1 = 1,
	X2 = -27,
	X3 = 19,
	Z = -1091.
	
	?- [X1,X2]::real(_,_),{X1+X2=<2}, global_maximum(log(1+X1)+2*log(1+X2),Z),splitsolve([X1,X2]).
	X1:: 0.33333...,
	X2:: 1.66666...,
	Z:: 2.24934... .
	
	?- [X1,X2]::real(0,_),{X1+2*X2=<3,8*X1+5*X2>=10}, global_minimum((X1-2)**2+(X2-2)**2,Z),splitsolve([X1,X2]).
	X1:: 1.39923...,
	X2:: 0.800381...,
	Z:: 1.80000... .
Most of these examples generate answers fairly quickly, but it's not hard to come up with examples that take a long time and millions of narrowing operations. Constraining the search space and using the tunable precision flag can help to produce acceptable answers in a reasonable time frame. And mixing local optimization techniques with global searches can result in sharper answers in less time as we'll see later.

##### The Knapsack Problem

The [Knapsack Problem] is a well researched problem in combinatorial optimization with many real world applications. It derives its name the problem of maximizing the value of items placed in a fixed-size knapsack. The example in the reference Wikipedia article describes a knapsack that can carry 15 kg. to be filled with coloured boxes with the following properties:
.tsv
	Colour		Weight(kg.)		Value
	Green		`12`			` 4`
	Grey		` 1`			` 2`
	Yellow		` 4`			`10`
	Orange		` 1`			` 1`
	Blue		` 2`			` 2`
First consider the case where there is only one box of each type:
eg
	﻿?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,1),
	{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	global_maximum(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,Take).
	Boxes = [0, 1, 1, 1, 1],
	Green = 0,
	Grey = Yellow, Yellow = Orange, Orange = Blue, Blue = 1,
	Take = 15.
In this case taking every box but the Green provides maximum value (15) even though the total weight is only 8 kg. Also note that the minimizer values are generated without an extra solve step.

Now consider the case where there is an unlimited supply of each coloured box:
eg
	﻿?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,_),
	{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	global_maximum(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,Take).
	Boxes = [Green, Grey, Yellow, Orange, Blue],
	Take = 36,
	Green::boolean,
	Grey::integer(0, 15),
	Yellow::integer(0, 3),
	Orange::integer(0, 15),
	Blue::integer(0, 7).
	
	﻿?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,_),
	{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	global_maximize(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,Take).
	Boxes = [0, 3, 3, 0, 0],
	Green = Orange, Orange = Blue, Blue = 0,
	Grey = Yellow, Yellow = 3,
	Take = 36.
	
	?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,_),
	{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	global_maximum(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,Take), splitsolve(Boxes).
	Boxes = [0, 3, 3, 0, 0],
	Green = Orange, Orange = Blue, Blue = 0,
	Grey = Yellow, Yellow = 3,
	Take = 36 ;
	false.
In this case the (only) optimal solution is to take 3 each of the Grey and Yellow boxes for a total value of 36 and an enumeration step (`splitsolve` or `enumerate`) is necessary to produce the minimizer values.

A variation on this simple knapsack problems is the multi-constraint problem, e.g., if the knapsack was constrained by volume in addition to weight. These can be simpley addressed by adding the additional constraints to the `{}` constraint term as can be seen in the following examples from Schaum's.
 
##### The Furniture Maker
"*A furniture maker has 6 units of wood and 28 h of free time, in which he will make decorative screens. Two models have sold well in the past, so he will restrict himself to those two. He estimates that model I requires 2 units of wood and 7 h of time, while model II requires 1 unit of wood and 8 h of time.  The prices of the models are $120 and $80 respectively. How many screens of each model should the furniture maker assemble if he wishes to maximize his sales revenue?*"

This integer problem can be easily expressed in CLP(BNR):
eg
	﻿?- [M_1,M_2]::integer(0,_), {2*M_1+M_2=<6, 7*M_1+8*M_2=<28}, global_maximum(120*M_1+80*M_2, Revenue).
	M_1 = 3,
	M_2 = 0,
	Revenue = 360.
Maximum revenue of $360 can be achieved by building 3 model I screens and no model II's.

##### "Universal Mines Inc."
"*Universal Mines Inc. operates three mines in West Virginia. The ore from each mine is separated into two grades before it is shipped; the daily production capacities of the mines, as well as their daily operating costs, are as follows:*
.tsv
	 		High-grade Ore, tons/day	Low-grade Ore, tons/day	Operating Cost, $1000/day
	Mine I			4							4						20
	Mine II			6							4						22
	Mine III		1							6						18
*Universal has committed itself to deliver 54 tons of high-grade ore and 65 tons of low-grade ore by the end of the week. It also has labor contracts that guarantee employees in each mine a full day’s pay for each day or fraction of a day the mine is open. Determine the number of days each mine should be operated during the upcoming week if Universal Mines is to fulfill its commitment at minimum total cost.*
 
*Hidden constraints: No mine may operate a negative number of days and no mine may operate more than 7 days in a week. In view of the labor contracts, Universal Mines has nothing to gain in operating a mine for part of a day.*"

The hidden constraints bound the days for each mine to `integer(0,7)`:
eg
	﻿?- [M_Idays,M_IIdays,M_IIIdays]::integer(0,7), Cost::integer(0,_),
	{4*M_Idays+6*M_IIdays+M_IIIdays >= 54, 4*M_Idays+4*M_IIdays+6*M_IIIdays >= 65}, 
	global_minimum(20*M_Idays+22*M_IIdays+18*M_IIIdays, Cost), splitsolve([M_Idays,M_IIdays,M_IIIdays]).
	M_Idays = 2,
	M_IIdays = 7,
	M_IIIdays = 5,
	Cost = 284 ;
	false.
Minimum cost (single solution) to achieve target production is $284,000 running Mine I for 2 days, Mine II for 7 days, and Mine 3 for 5 days.

##### The Investor
"*An individual has $4000 to invest and three opportunities available to him. Each opportunity requires deposits in $1000 amounts; the investor may allocate all the money to just one opportunity or split the money between them. The expected returns are tabulated as follows:*
.tsv
	Dollars Invested:		0	1000	2000	3000	4000
	Return Opportunity 1	0	2000	5000	6000	7000
	Return Opportunity 2	0	1000	3000	6000	7000
	Return Opportunity 3	0	1000	4000	5000	8000
*How much money should be invested in each opportunity to obtain the greatest total return?*"

The returns are not simple functions of dollars invested, but can be expressed by boolean expressions to separate the various cases:
eg
	﻿?- [Op1,Op2,Op3]::integer(0,4), {Op1+Op2+Op3 =< 4},
	global_maximize((Op1==1)*2 + (Op1>1)*(Op1+3) +
	 (Op2==1) + (Op2==2)*3 + (Op2>2)*(Op2+3) +
	 (Op3==1) + (Op3==2)*4 + (Op3==3)*5 +(Op3==4)*8, Return).
	Op1 = Op3, Op3 = 2,
	Op2 = 0,
	Return = 9.
The maximum return can be be realized by investing $2000 in each of opportunity 1 and opportunity 3.

##### "Aztec Refining Company"
"*The Aztec Refining Company produces two types of unleaded gasoline, regular and premium, which it sells to its chain of service stations for $12 and $14 per barrel, respectively. Both types are blended from Aztec’s inventory of refined domestic oil and refined foreign oil, and must meet the following specifications:*
.tsv
	 	Maximum Vapor Pressure	Minimum Octane Rating	Maximum Demand, bbl/wk	Minimum Deliveries, bbl/wk
	Regular		23						88						100000					50000
	Premium		15						98						20000					5000
*The characteristics of the refined oils in inventory are as follows:*
.tsv
	 	Vapor Pressure	Octane Rating	Inventory, bbl	Cost, $/bbl
	Domestic	25			87				40000			8
	Foreign		15			98				60000			15
*What quantities of the two oils should Aztec blend into the two gasolines in order to maximize weekly profit?*"

If:
>	`RegDom` = barrels of domestic blended into regular
	`RegFor` = barrels of foreign blended into regular
	`PremDom` = barrels of domestic blended into premium
	`PremFor` = barrels of foreign blended into premium
then `Profit` is revenue from sales of regular and premium gas minus the cost of of foreign and domestics oil used it the production:
>	`Profit = 12*(RegDom+RegFor) + 14*(PremDom+PremFor) - 8*(RegDom+PremDom) - 15*(RegFor+PremFor)`
	`       = 4*RegDom - 3*RegFor + 6*PremDom - PremFor`
Additional constraints are imposed by the demand and available inventory:
>	`RegDom+RegFor =< 100000` (maximum demand for regular)
	`RegDom+RegFor >= 50000` (minimum regular required)
	`PremDom+PremFor =< 20000` (maximum demand for premium)
	`PremDom+PremFor >= 5000` (minimum premium required)
	`RegDom+PremDom =< 40000` (domestic)
	`RegFor+PremFor =< 60000` (foreign)
And finally, the constituents of a blend contribute to the overall octane rating according to their percentages by weight; likewise for the vapor pressure:
>	`10*RegFor-RegDom >= 0` (regular octane constraint: ((87xRegDom)+(98xRegFor))/(RegDom+RegFor) >= 88 )
	`5*PremFor-6*PremDom >= 0` (premium octane constraint)
	`2*RegDom-8*RegFor =< 0` (regular vapor pressure constraint: ((25xRegDom)+(15xRegFor))/(RegDom+RegFor) =< 23 )
	`2*PremDom-8*PremFor =< 0` (premium vapor pressure constraint)
Just calculating the maximum profit to 3 decimal places still takes several seconds:
eg
	﻿?- [RegDom,RegFor,PremDom,PremFor]::real(0,_), OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	{
	RegDom+RegFor=<100000, RegDom+RegFor>=50000, PremDom+PremFor=<20000, PremDom+PremFor>=5000,
	RegDom+PremDom=<40000, RegFor+PremFor=<60000,
	10*RegFor-RegDom>=0, 5*PremFor-6*PremDom>=0, 2*RegDom-8*RegFor=<0, 2*PremDom-8*PremFor=<0
	},
	global_maximum(OF,Profit,3),
	{Regular==RegDom+RegFor, Premium==PremDom+PremFor, Domestic==RegDom+PremDom, Foreign==RegFor+PremFor}.
	OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	RegDom::real(13735.04638671875, 40000),
	RegFor::real(10000, 45019.938151041664),
	PremDom::real(0, 16666.666666666668),
	PremFor::real(0, 20000),
	Profit::real(124940.185546875, 125059.814453125),
	Regular::real(23735.04638671875, 85019.93815104167),
	Premium::real(0, 36666.666666666664),
	Domestic::real(13735.04638671875, 56666.666666666664),
	Foreign::real(10000, 65019.938151041664).
The profit is in the neighbourhood of $125,000, but to calculate the amounts of each oil type to use and each type of gasoline to produce, the minimizers must be calculated. This can be done by using the generated single solution produced by `global_minimize` or by using one of the solve predicates, in this case `splitsolve`:
eg
	﻿?- [RegDom,RegFor,PremDom,PremFor]::real(0,_), OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	{
	RegDom+RegFor=<100000, RegDom+RegFor>=50000, PremDom+PremFor=<20000, PremDom+PremFor>=5000,
	RegDom+PremDom=<40000, RegFor+PremFor=<60000,
	10*RegFor-RegDom>=0, 5*PremFor-6*PremDom>=0, 2*RegDom-8*RegFor=<0, 2*PremDom-8*PremFor=<0
	},
	global_maximize(OF,Profit,3), 
	{Regular==RegDom+RegFor, Premium==PremDom+PremFor, Domestic==RegDom+PremDom, Foreign==RegFor+PremFor}.
	OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	RegDom::real(37730.712890625, 37739.2578125),
	RegFor::real(12260.7421875, 12269.287109375),
	PremDom::real(2260.7421875, 2269.287109375),
	PremFor::real(2730.712890625, 2739.2578125),
	Profit::real(124940.185546875, 125059.814453125),
	Regular::real(49991.455078125, 50008.544921875),
	Premium::real(4991.455078125, 5008.544921875),
	Domestic::real(39991.455078125, 40008.544921875),
	Foreign::real(14991.455078125, 15008.544921875).
	
	﻿?- [RegDom,RegFor,PremDom,PremFor]::real(0,_), OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	{
	RegDom+RegFor=<100000, RegDom+RegFor>=50000, PremDom+PremFor=<20000, PremDom+PremFor>=5000,
	RegDom+PremDom=<40000, RegFor+PremFor=<60000,
	10*RegFor-RegDom>=0, 5*PremFor-6*PremDom>=0, 2*RegDom-8*RegFor=<0, 2*PremDom-8*PremFor=<0
	},
	global_maximum(OF,Profit,3), splitsolve([RegDom,RegFor,PremDom,PremFor]),
	{Regular==RegDom+RegFor, Premium==PremDom+PremFor, Domestic==RegDom+PremDom, Foreign==RegFor+PremFor}.
	OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	RegDom:: 37712.62...,
	RegFor:: 12287.3...,
	PremDom:: 2281.62...,
	PremFor:: 2737.95...,
	Profit:: 124940.2...,
	Regular:: 50000.0...,
	Premium:: 5019.5...,
	Domestic:: 39994.2...,
	Foreign:: 15025.3... .
In this case using `splitsolve` is of dubious value since there are very many possible answers given the wide domain of `Profit`. Due to order of the search used by `splitsolve`, a solution at the low end of the profit range is generated: produce 50,000 barrels of regular and ~5020 barrels of premium gas using ~39994 barrels of domestic and ~15025 barrels of foreign oil.

This is quite close to the precise answer for this problem, a profit of $125,000 (50,000 regular and 5,000 premium barrels using 40,000 domestic and 15000 foreign barrels). If necessary, one way of "sharpening" the answer is to increase the precision value argument to `global_maximum` at the expense of longer calculation time:
eg
	﻿?- [RegDom,RegFor,PremDom,PremFor]::real(0,_), OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	{
	RegDom+RegFor=<100000, RegDom+RegFor>=50000, PremDom+PremFor=<20000, PremDom+PremFor>=5000,
	RegDom+PremDom=<40000, RegFor+PremFor=<60000,
	10*RegFor-RegDom>=0, 5*PremFor-6*PremDom>=0, 2*RegDom-8*RegFor=<0, 2*PremDom-8*PremFor=<0
	},
	global_maximize(OF,Profit,4),
	{Regular==RegDom+RegFor, Premium==PremDom+PremFor, Domestic==RegDom+PremDom, Foreign==RegFor+PremFor}.
	OF = 4*RegDom-3*RegFor+6*PremDom-PremFor,
	RegDom::real(39999.237060546875, 40000),
	RegFor::real(10000, 10000.762939453125),
	PremDom::real(0, 0.762939453125),
	PremFor::real(4999.237060546875, 5000),
	Profit::real(124994.65942382812, 125005.34057617188),
	Regular::real(49999.237060546875, 50000.762939453125),
	Premium::real(4999.237060546875, 5000.762939453125),
	Domestic::real(39999.237060546875, 40000.762939453125),
	Foreign::real(14999.237060546875, 15000.762939453125).
But this is a fair amount of additional work for not much gain (for this particular problem). A different approach to generating better results in less time is discussed below.

##### Optimizing Linear Systems

Predicates `global_maximum` and `global_minimum` are implemented as directed branch-and-bound searches. They can be used for almost any problem but for linear systems there exist algorithms which can calculate optima directly and will usually be much more efficient than searching for solutions. (This is analogous to using Cramer's rule for solving a set of linear equations as discussed previously.) `library(simplex)` which is contained in the distributed SWI-Prolog library provides such an algorithm for optimization of linear systems but the API is somewhat foreign from the perspective of CLP's. Module `clpBNR_toolkit`, distributed with `clpBNR`, provides a "friendlier" API for `clpBNR` users in the form of `lin_minimum/3` and `lin_maximum/3`.

`lin_minimum/3` and `lin_maximum/3`'s arguments are an objective expression `ObjF` to be min/maximized, a set of constraints, `{Constraints}`, as expressed in `clpBNR` notation, and unifies the third argument, `OptValue`, with max/minimum value of the objective expression subject to those constraints. Like `global_maximum` and `global_minimum` they do not narrow any contained variables to the maximizer/minimizer values; these can be generated by a subsequent labelling step using `splitsolve` for example. However, a constraint is applied equating the calculated value with the objective expression (i.e., `{ObjF==OptValue}`). Also all constraints are also applied, so this doesn't have to be done beforehand (as when using the global optimizing predicates in module `clpBNR`.

"The Furniture Maker" example:
eg
	?- [M_1,M_2]::integer, lin_maximum(120*M_1+80*M_2,{2*M_1+M_2=<6,7*M_1+8*M_2=<28},Revenue).
	M_1 = 3,
	M_2 = 0,
	Revenue = 360.
Since `library(simplex)` is specifically for linear systems, there are limitations placed on the objective expression and the constraints. Specifically, the expression and the right hand side of the constraints must be "linear", i.e., a sum of terms of the form `Number*Var` (or `Var*Number`). The relational operator  in the constraint must be one of `=<`, `>=`, or `==`, and the left hand side of the constraint must be a positive number. All variables must be non-negative, and will be constrained to be so if not already. 

"The Knapsack Problem" using `lin_maximum/3`:
eg
	﻿?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,_),
	lin_maximum(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	Take).
	Boxes = [Green, Grey, Yellow, Orange, Blue],
	Take = 36,
	Green::boolean,
	Grey::integer(0, 15),
	Yellow::integer(0, 3),
	Orange::integer(0, 15),
	Blue::integer(0, 7).
	
	?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,_),
	lin_maximum(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	Take),splitsolve(Boxes).
	Boxes = [0, 3, 3, 0, 0],
	Green = Orange, Orange = Blue, Blue = 0,
	Grey = Yellow, Yellow = 3,
	Take = 36 ;
	false.

The "Universal Mines Inc." example:
eg
	?- [M_Idays,M_IIdays,M_IIIdays]::integer(0,7),
	lin_minimum(20*M_Idays+22*M_IIdays+18*M_IIIdays,
	{4*M_Idays+6*M_IIdays+M_IIIdays>=54,4*M_Idays+4*M_IIdays+6*M_IIIdays>=65},
	Min).
	Min = 284,
	M_Idays::integer(2, 7),
	M_IIdays::integer(4, 7),
	M_IIIdays::integer(2, 7).
	
	?- [M_Idays,M_IIdays,M_IIIdays]::integer(0,7),
	lin_minimum(20*M_Idays+22*M_IIdays+18*M_IIIdays,
	{4*M_Idays+6*M_IIdays+M_IIIdays>=54,4*M_Idays+4*M_IIdays+6*M_IIIdays>=65},
	Min),splitsolve([M_Idays,M_IIdays,M_IIIdays]).
	M_Idays = 2,
	M_IIdays = 7,
	M_IIIdays = 5,
	Min = 284 ;
	false.
The second query in the previous two examples uses `splitsolve` to generate all solutions; in each case there is only one. As discussed previously, it is often the case that the only requirement is to find *any* solution. `library(simplex)` does calculate a set of min/maximizer values corresponding to the optimal objective requested. Predicates `lin_minimize/3` and `lin_maximize/3` will bind any variables to the calculated values so there is no need to use a labelling predicate to do so. This is the most efficient way to calculate a complete solution for linear optimization problems. Using previous examples:
eg

	﻿?- [M_Idays,M_IIdays,M_IIIdays]::integer(0,7),lin_minimize(20*M_Idays+22*M_IIdays+18*M_IIIdays,{4*M_Idays+6*M_IIdays+M_IIIdays>=54,4*M_Idays+4*M_IIdays+6*M_IIIdays>=65},Min).
	M_Idays = 2,
	M_IIdays = 7,
	M_IIIdays = 5,
	Min = 284.
	
	﻿?- Boxes=[Green,Grey,Yellow,Orange,Blue], Boxes::integer(0,_),
	lin_maximize(Green*4+Grey*2+Yellow*10+Orange*1+Blue*2,{Green*12+Grey*1+Yellow*4+Orange*1+Blue*2 =< 15},
	Take).
	Boxes = [0, 3, 3, 0, 0],
	Green = Orange, Orange = Blue, Blue = 0,
	Grey = Yellow, Yellow = 3,
	Take = 36.
	
	﻿?- [RegDom,RegFor,PremDom,PremFor]::real, 
	lin_maximize(4*RegDom-3*RegFor+6*PremDom-PremFor,
	{RegDom+RegFor=<100000, RegDom+RegFor>=50000, PremDom+PremFor=<20000, PremDom+PremFor>=5000,
	RegDom+PremDom=<40000, RegFor+PremFor=<60000,  
	10*RegFor-RegDom>=0, 5*PremFor-6*PremDom>=0, 2*RegDom-8*RegFor=<0, 2*PremDom-8*PremFor=<0},
	Max), RegDomF is float(RegDom), RegForF is float(RegFor), PremDomF is float(PremDom), PremForF is float(PremFor).
	RegDom = 415000r11,
	RegFor = 135000r11,
	PremDom = 25000r11,
	PremFor = 30000r11,
	Max = 125000,
	RegDomF = 37727.27272727273,
	RegForF = 12272.727272727272,
	PremDomF = 2272.7272727272725,
	PremForF = 2727.2727272727275.
The last example demonstrates an important feature of `library(simplex)`, namely that it uses rational arithmetic to avoid the unsound properties of floating point arithmetic. Any floating point constants in the objective expression or constraints are treated as precise values and converted to rational numbers before any calculations are done. This remains safe as long as the rational numbers do not exceed the `max_rational_size` value (a SWI-Prolog environment flag - also see section 4.27.2 of [[SWIP Manual - Arithmetic]]). Unfortunately, the rational results can be hard to interpret so this example also generates the (approximate) floating point equivalents.

As an extreme example consider "[The Stigler Diet Problem]" which has 9 linear constraints in 77 variables. Applying a bifurcating search like `splitsolve` or `enumerate` on 77 variables is impractical but `lin_minimize` produces the documented solution (there may be more?) in less than 0.1 second. 

##### Bin Packing

A bin packing problem is one where one is given an assortment of objects of different types which are to be grouped into "bins" and where there are restrictions on the number and type of objects that can be placed in a bin. Such problems are often good abstract models for practical problems arising in the configuration of complex systems which often require a mix of boolean and (usually) integer constraints.

The challenge of using constraints on such problems is often that of mapping a symbolic or informal description to numeric constraints. Then a search technique must be defined to find an optimal solution to the problem; generally many such solutions exits but any one of them is normally acceptable. However simple searching strategies, even when constrained, typically do not scale well. Fortunately, bin packing problems are usually linear optimization problems so, using an alternative model formulation, searching can be replaced by `lin_minimize/3` resulting in much better scalability.

The rest of this section examines two hypothetical bin packing problems which illustrate these approaches. (Complete program source for these examples can be found in [Appendix - Bin_Packing_Examples]).

##### Loading Camels
As a first example, consider the problem of transporting a set of items using a minimum number of camels as defined in [Camels]. The problem input data includes 3 lists which define the properties of the item types; each item type has a value, a weight, and a demand, i.e., the number of items of that type to be transported. A example of such data for a problem with 3 item types is:
.pl
	weights(3, [30,20,50]).
	values( 3, [90,70,20]).
	demands(3, [12,7,15]).
(The first argument is just a key so that several such datasets can be defined in a file; in this case the key is just the number of item types.)

A camel is defined by its ability to carry items. In this case the total value of the carried items cannot not exceed 200 and the total weight cannot exceed 100. The following captures this given the `weight` and `values` lists as input:
.pl
	% define what a camel can do
	camel(Weights,Values,Load,Count) :-
		length(Weights,L), 
		length(Load,L), Load::integer(0,_),  % Load is list of item counts
		Weight::integer(1,100),  % weight can't exceed 100 but must be > 0
		sym_sum_prod(Load,Weights,SumW),
		{Weight == SumW},
		Value::integer(1,200),   % value can't exceed 200 but must be > 0
		sym_sum_prod(Load,Values,SumV),	
		{Value == SumV},
		Count::integer(1,_),     % total load (number of items of any kind)
		sym_sum_list(Load,SumL),
		{Count == SumL}.
`Load` is a list (by item type) of the number of each item type carried by a camel. Since no `Load` has been assigned it's just a list of constrained integers. The (redundant but useful) `Count` is just the total count of items carried, also a constrained integer. To produce a list of all the possible camel "configurations", just `enumerate(Load)`:
eg
	 ?- weights(3,Weights), values(3,Values), findall((Count,Load), (camel(Weights,Values,Load,Count),enumerate(Load)), Configs).
	 Weights = [30, 20, 50],
	 Values = [90, 70, 20],
	 Configs = [
	  (1, [0, 0, 1]), 
	  (2, [0, 0, 2]), 
	  (1, [0, 1, 0]), 
	  (2, [0, 1, 1]), 
	  (2, [0, 2, 0]), 
	  (3, [0, 2, 1]), 
	  (1, [1, 0, 0]), 
	  (2, [1, 0, 1]), 
	  (2, [1, 1, 0]), 
	  (3, [1, 1, 1]), 
	  (2, [2, 0, 0])
	].
The general approach is to start with no camels and then keep adding them until a solution that meets the demand is found. This is done in two steps: use predicate `pack_/5` add a camel and reduce the demand by the load applied to the expanded set of camels (as a set of new constraints), then "enumerate" the set of camel `Load`'s using `enum_camels/1` to find a solution that fits. Stop adding camels when the demand is reduced to exactly zero. (This is a slightly different problem than the relaxed linear problem solved in [Camels].) The implementation of these two predicates:
.pl
	% load additional camels until residual item count reaches 0
	% camel load defined by (Count,Load) where Count is sum of Load elements
	camel_load_(0,Items,_,_,[]) :-
		zero_list_(Items).
	camel_load_(Total,Items,Weights,Values,[(Count,Load)|Camels]) :-
		camel(Weights,Values,Load,Count),          % new camel
		{NxtTotal == Total-Count, NxtTotal >= 0},  % reduces total item count
		subtract_clp(Items,Load,Residual),         % and count of each item type
		camel_load_(NxtTotal,Residual,Weights,Values,Camels).  % adds more as needed
	
	zero_list_([]).
	zero_list_([0|Items]) :-
		zero_list_(Items).
	
	subtract_clp([], [], []).
	subtract_clp([X|Xs], [Y|Ys], [Z|Zs]) :-
		{Z == X - Y, Z >= 0},  % can't get to -ve items
		subtract_clp(Xs,Ys,Zs).
	
	enum_camels([]).
	enum_camels([(_Count,Load)|Camels]) :-
		enumerate(Load),
		enum_camels(Camels).
This all works but has a flaw. Enumeration will generate many equivalent solutions with the same "camels", just in a different order. To break this symmetry, add constraints which requires the list to be sorted by the number of items carried. This doesn't remove all the permutations (no order is defined if the carried items is the same), but it significantly improves the performance for most problems. The "order" constraint on a list of "camels" is defined as:
.pl
	camels_ordered_([_]) :- !.         % finish with one item
	camels_ordered_([X,Y|Xs]) :-
		order_camels(X,Y),             % order constraint on first two items
		camels_ordered_([Y|Xs]).       % order second and remaining items
	
	order_camels((C1,_L1), (C2,_L2)) :- {C1>=C2}.  % constrain camel order by carried items
The top level program which packs a "demand" list of items to a list of camels:
.pl
	pack_camels(Items,CamelSpec,Required) :-
		setup_camels_(Items,Total,Weights,Values),
		camel_load_(Total,Items,Weights,Values,Camels),  % incrementally adds camels as needed
		camels_ordered_(Camels),        % order list to break order symmetry
		enum_camels(Camels), !,         % commit to first solution
		msort(Camels,SCamels),          % sort result by load count for output
		accumulate_camels_(SCamels,CamelSpec,0,Required).

	setup_camels_(Items,Total,Weights,Values) :- 
		length(Items,L),
		weights(L,Weights),
		values(L,Values),
		lists:sum_list(Items,Total).
Note that, due to the '`!`', only the first solution is generated (remove the cut to generate more) and the solution is optimal as defined by the number of camels used, since no solutions using fewer camels have been generated. `msort/2` and `accumulate_camels_/2` are just used to provide more readable top level output:
eg
	?- demands(3,Items), pack_camels(Items,Camels,Required).
	Items = [12, 7, 15],
	Camels = [4*[0, 0, 2], 1*[1, 0, 1], 3*[2, 0, 0], 1*[0, 2, 1], 5*[1, 1, 1]],
	Required = 14.
The value of `Camels` is a list of the form `N*Load` where `Load` is the list of items (by type) carried by that camel and `N` is the number of camels carrying that load. In this case `14` (`4+1+1+5+3`) camels are need to satisfy the demand.

While simple, the problem with this solution is that it doesn't scale well. Increasing the demand or the number of item types can cause exponential increase in the time taken to find a solution. For example, if one doubles the amount of each type (for a demand of `[24, 14, 30]`) results in an increase by a factor of 100 in the execution time. The constraints do an effective job at causing early failure when the number of camels is much less then the eventual minimum required, but as the number approaches a solution, the number of possible solutions to test becomes quite large before ultimately failing.

An alternative model constructs a list of all the possible camel "load configurations" much like was shown above  to test the `camel/4` predicate. The problem can then be restated as how much of each configuration is required to meet the demand; minimizing the total number of used configurations (the objective expression) required defines an optimal solution. The sum of each item type over these used configurations to meet the specified demand, defines the constraints. Both are linear expressions so `lin_minimize/3` can be used to efficiently generate a solution:
.pl
	fastpack_camels(Items,CamelSpec,Required) :-
		setup_camels_(Items,_Total,Weights,Values),  % process input data
		% generate possible load patterns
		findall(Load, (camel(Weights,Values,Load,_Count),enumerate(Load)), Loads),
		% use Items and Loads to define linear objective expression and constraints 
		camels_lin_summation(Items,Loads,NC,Obj,Constraints),
		lin_minimize(Obj,{Constraints},_Min),         % and minimize
		accumulate_camels_(NC,CamelSpec,0,Required).  % format for output
	
	camels_lin_summation(Items,Loads,NC,Obj,Constraints) :-
		map_camel_loads(Loads,Ns,NC),  % lists of pattern counts
		sym_sum_list(Ns,Obj),          % Objective function is sum of counts
		length(Items,TLen),            % construct constraint for each type
		lin_constraints_camels(0,TLen,Items,Loads,Ns,Constraints).
	
	map_camel_loads([],[],[]).
	map_camel_loads([Load|Loads],[N|Ns],[N*Load|NCs]) :-
		N::integer(0,_),
		map_camel_loads(Loads,Ns,NCs).
		
	lin_constraints_camels(T,T,_,_,_,[]) :- !.
	lin_constraints_camels(T,TLen,Items,Loads,Ns,[LHS==RHS|Constraints]):-
		camel_lhs_constraint_(Loads,Ns,T,LHS),  % constraint LHS for item type T
		nth0(T,Items,RHS),                      % constraint RHS for item type T
		TNxt is T+1,                            % next type
		lin_constraints_camels(TNxt,TLen,Items,Loads,Ns,Constraints).
	
	% constraint LHS for type T = sum(Load[T]*N)
	camel_lhs_constraint_([Load],[N],T, L*N) :- !,  % last Load - minimum form
		nth0(T,Load,L).
	camel_lhs_constraint_([Load|Loads],[N|Ns],T, RHS) :-
		nth0(T,Load,L),                         % Load[T]
		(L==0 -> RHS = RHS1 ; RHS = L*N+RHS1),  % omit if Load[T] == 0
		camel_lhs_constraint_(Loads,Ns,T,RHS1).
Note that this generates an optimal solution but not the same one generated by `pack_camels/3`:
eg
	?- demands(3,Items), fastpack_camels(Items,Camels,Required).
	Items = [12, 7, 15],
	Camels = [2*[0, 0, 2], 1*[0, 1, 1], 4*[1, 0, 1], 6*[1, 1, 1], 1*[2, 0, 0]],
	Required = 14.
But unlike `pack_camels`, this solution scales quite well. The 21 item problem from [Camels] is the worst case with 900 possible configurations and takes a couple of seconds, the other examples take less than half a second. Note that constraints are use here primarily to generate the list of configurations; expensive enumeration is replaced by the simplex algorithm tailored to linear optimization problems. Combining well known numerical methods with constraints can lead to effective solutions.
&
	[Camels] <- link https://www.metalevel.at/various/colgen/

##### Packing Coloured Bins
As a second example, consider the problem of packing three types of bins (red, blue, and green) with five types of commodities (glass, plastic, steel, wood, and copper), subject to the following rules:
- bins have limited capacity: red bins can hold 3 items, blue, 1 item, and green, 4 items.
- a bin with a wood item must also have a plastic item
- glass or plastic items cannot be put in the same bin as a copper item
- blue bins cannot hold wood or plastic items
- red bins cannot hold steel or plastic items and at most 1 wood item
- green bins cannot hold steel or glass items and at most 2 wood item
Using a mixture of integer arithmetic and boolean logic, this can be represented with constraints as:
.pl
	% pack 3 bin types with 5 types of commodities
	bin_types([red,green,blue]).
	
	commodities([glass, plastic, steel, wood, copper]).
	
	% define a bin with constraints
	bin(Type, Contents, Total):-
		Type::integer(1,3),                               % enumeration of 3 bin types
		{Red == (Type==1), Green == (Type==2), Blue == (Type==3)}, % true if bin the designated colour
		Binsize::integer(1,4),                            % bin capacity, colour dependent
		{Binsize == Red*3 + Blue*1 + Green*4},            % "conditional" expression
		Contents=[Glass,Plastic,Steel,Wood,Copper], Contents::integer(0,_),
		Total::integer(1,_),                              % % bin contains Total items (at least 1)
		{Total == Glass + Plastic + Steel + Wood + Copper, Total =< Binsize},  
		{(Wood >= 1) -> (Plastic >= 1)},                  % wood requires plastic
		{Glass * Copper == 0},                            % glass excludes copper
		{Copper * Plastic == 0},                          % copper excludes plastic
		{Blue  -> (Wood + Plastic == 0)},                 % blue bin -> no plastc or wood
		{Red   -> ((0==Steel + Plastic) and (Wood=<1))},  % red bin -> no steel or plastic, no more than 1 wood
		{Green -> ((0==Glass + Steel) and (Wood=<2))}.    % green bin -> no steel or plastic, no more than 2 wood
`Red`, `Green` and `Blue` are implicit booleans which are used to constrain contents based on bin type, e.g., `{Blue  -> (Wood + Plastic == 0)}` says "the bin is blue implies no wood or plastic". With a definition of a bin established, the rest of the program is very similar to the previous "camels" example (source code for both examples in [Appendix - Bin_Packing_Examples]):
.pl
	pack_bins(Items,Bins,Required) :-
		setup_bins_(Items,Total,ItemsRaw),  % process input
		bin_load_(Total,ItemsRaw,BinsRaw),  % add a bin (further add on backtracking)
		bins_ordered_(BinsRaw),             % order bins to break symmetry
		enum_bins_(BinsRaw), !,             % enumerate bin type and contents - single solution
		accumulate_bins_(BinsRaw,Bins,0,Required).  % format for output
		
	bin_load_(0, [0,0,0,0,0], []).
	bin_load_(Total, Amounts, [bin(Type,Contents,Size)|Bins]) :-
		bin(Type,Contents,Size),                    % new bin
		{T == Total - Size, T>=0},                  % decrease total by bin capacity
		subtract_clp(Amounts, Contents, Residual),  % decrease each commodity using bin contents
		bin_load_(T, Residual, Bins).               % repeat until feasible solution exists
	
	bins_ordered_([_]) :- !.
	bins_ordered_([X,Y|Xs]) :- order_bins_(X,Y), bins_ordered_([Y|Xs]).
	
	order_bins_(bin(T1,_,S1), bin(T2,_,S2)) :-
		{(T1<T2) or ((T1==T2) and (S1=<S2))}.
	
	subtract_clp([], [], []).
	subtract_clp([X|Xs], [Y|Ys], [Z|Zs]) :-
		{Z == X - Y, Z >= 0},  % can't get to -ve items
		subtract_clp(Xs,Ys,Zs).
	
	enum_bins_([]).
	enum_bins_([bin(T,C,_S)|Bs]):- 
		enumerate([T|C]),  % enumerate 
		enum_bins_(Bs).
A simple example query:
eg
	?- pack_bins([3*glass, 4*plastic, 1*steel, 4*wood, 2*copper],Bins,Required).
	Bins = [1*red(2*copper), 1*red(3*glass), 2*green(2*plastic, 2*wood), 1*blue(1*steel)],
	Required = 5.
But as with the camels example, a modest increase in number of items drastically increases the execution time. Applying the same optimization using load "patterns" produces a significantly more scalable solution:
.pl
	fastpack_bins(Items,Bins,Required) :-
		setup_bins_(Items,_Total,ItemsRaw),        % process input
		% generate possible load patterns
		findall(bin(Type,Contents,Size), (bin(Type, Contents, Size), enumerate([Type|Contents])), BinDefs),
		% use ItemsRaw and BinDefs to define linear objective expression and constraints 
		bins_lin_summation(ItemsRaw,BinDefs,NBins,Obj,Constraints),
		lin_minimize(Obj,{Constraints},_Min),      % and minimize
		accumulate_bins_(NBins,Bins,0,Required).   % format for output
	
	bins_lin_summation(Items,BinDefs,NBins,Obj,Constraints) :-
		bins_list(BinDefs,Ns,NBins),  % lists of pattern counts
		sym_sum_list(Ns,Obj),         % Objective function is sum of counts
		length(Items,TLen),           % construct constraint for each type
		lin_constraints_bins(0,TLen,Items,BinDefs,Ns,Constraints).
	
	bins_list([],[],[]).
	bins_list([Bin|BinDefs],[N|Ns],[N*Bin|NBins]) :-
		N::integer(0,_),
		bins_list(BinDefs,Ns,NBins).
		
	lin_constraints_bins(T,T,_,_,_,[]) :- !.
	lin_constraints_bins(T,TLen,Items,BinDefs,Ns,[LHS==RHS|Constraints]):-
		bin_lhs_constraint_(BinDefs,Ns,T,LHS),
		nth0(T,Items,RHS),
		T1 is T+1,	
		lin_constraints_bins(T1,TLen,Items,BinDefs,Ns,Constraints).
		
	bin_lhs_constraint_([bin(_,Contents,_)],[N],T, CI*N) :- !,
		nth0(T,Contents,CI).
	bin_lhs_constraint_([bin(_,Contents,_)|BinDefs],[N|Ns],T, RHS) :-	
		nth0(T,Contents,CI),
		(CI==0
		 -> bin_lhs_constraint_(BinDefs,Ns,T,RHS)
		 ;  RHS = CI*N+RHS1,
			bin_lhs_constraint_(BinDefs,Ns,T,RHS1)
		).
	
	sym_sum_list([X],X) :- !.
	sym_sum_list([X|Xs],X+XS) :-
		sym_sum_list(Xs,XS).
Examples:
eg
	?- fastpack_bins([3*glass, 4*plastic, 1*steel, 4*wood, 2*copper],Bins,Required).
	Bins = [1*red(2*copper), 1*red(3*glass), 2*green(2*plastic, 2*wood), 1*blue(1*steel)],
	Required = 5.

	?- fastpack_bins([132*glass,414*plastic,1001*steel,414*wood,230*copper],Bins,Required).
	Bins = [44*red(3*glass), 2*green(3*copper), 56*green(4*copper), 207*green(2*plastic, 2*wood), 1001*blue(1*steel)],
	Required = 1310.
It isn't feasible to use `pack_bins/3` to find a solution to the second example, but both examples take roughly the same time (much less than 0.1 sec.) using `fastpack_bins`.

Many optimization problems can be modelled as a linear system so it's worthwhile having special purpose tools within a CLP framework to tackle these kinds of problems. Other techniques that can be applied to non-linear problems are discussed in the next section.

##### Redundant Constraints using Local Optimization 

Earlier sections described using common numerical techniques to rewrite or create redundant constraints to improve answers and reduce execution times. These techniques can be applied because the underlying arithmetic system is mathematically sound so there can be confidence in the answers produced - rounding errors may result in "wider" answers but should never produce wrong answers.

For non-linear problems, if the assumption can be made that global optima are also local optima, and the objective function and constraints have certain properties, additional constraints can be defined which generally result in better answers in less time. (This isn't always the case since additional time is required to check the additional constraints which may not always result in a pruning of the search space.) For unconstrained optimization, this takes the form of constraining the gradient to be zero at the local optima. For constrained optimizations involving equalities and inequalities, techniques involving Lagrangian functions and [Karush–Kuhn–Tucker] conditions can be used. These will not be described in detail in this document, but information can be readily found in any text on solving local optimization problems.
 
The local optimization technique described requires that the objective function and all constraints must be continuously differentiable over the range of all variables of interest. This precludes functions such as `max` and `abs`. In general, functions of `integer` intervals cannot be used because local optima are not necessarily found at integral values.

The accompanying `clpBNR_toolkit` module exports a couple of predicates to apply local minima and maxima constraints to constrained and unconstrained optimization problems. For unconstrained problems use `local_minima(ObjExp)` and `local_minima(ObjExp)`; for constrained optimization use `local_minima(ObjExp,{Constraints})` and `local_minima(ObjExp,{Constraints})`. Note that these do not generate any minimum or maximum values; they jsut apply the additional contraints that will be applied when `global_minimum` or `global_maximum` is called. For this reason, `local_minima` should be paired with `global_minimum` and `local_maxima` with `global_maximum`.

`local_minima/2` and `local_maxima/2` also apply the `{Constraints}` so there is no need to do this separately.

A simple example of unconstrained optimization with and without local optima constraints:
eg
	?- X::real(0,20), global_maximum(X*(5*pi-X),Z).
	 X:: 7.8...,
	 Z:: 61.6850... .
	 
	?- X::real(0,20), global_maximum(X*(5*pi-X),Z),splitsolve(X).
	X:: 7.84965...,
	Z:: 61.6850... .
	
	﻿?- X::real(0,20), OF=X*(5*pi-X), local_maxima(OF), global_maximum(OF,Z).
	OF = X*(5*pi-X),
	X:: 7.85398163397448...,
	Z:: 61.685027506808... ;
	false.
Note that the additional constraints produce a much sharper answer in much less time (orders of magnitude for this simple example). And the search finds the single solution without requiring the use of solve to find the minimizer.

Other examples:
eg
	﻿?- [X1,X2]::real,OF=log(1+X1)+2*log(1+X2), local_maxima(OF,{X1+X2=<2}),global_maximum(OF,Z).
	OF = log(1+X1)+2*log(1+X2),
	X1:: 0.33333333333333...,
	X2:: 1.66666666666666...,
	Z:: 2.24934057847523... .

	﻿?- [X1,X2]::real, OF=(X1-2)**2+(X2-2)**2, local_minima(OF,{X1+2*X2=<3,8*X1+5*X2>=10}),global_minimum(OF,Z).
	OF =  (X1-2)**2+(X2-2)**2,
	X1:: 1.400000000000000...,
	X2:: 0.800000000000000...,
	Z:: 1.80000000000000... ;
	false.
Again much sharper answers in much less time. In general, it's advantageous to use `local_minima` and `local_maxima` but this requires that a local critical point exists within the domain defined by the problem. If such is not the case the search may fail, i.e. the global optima is at a boundary. In this case, it make take an excessive amount of time and/or stack space to find it by exhaustive search. A couple of other non-linear optimization examples follow.

##### "Cheese Shop"
"*A cheese shop has 20 lb of a seasonal fruit mix and 60 lb of an expensive cheese with which it will make two cheese spreads, delux and regular, that are popular during Christmas week. Each pound of the delux spread consists of 0.2 lb of the fruit mix and 0.8 lb of the expensive cheese, while each pound of the regular spread consists of 0.2 lb of the fruit mix, 0.3 lb of the expensive cheese, and 0.5 lb of a filler cheese which is cheap and in plentiful supply. From past pricing policies, the shop has found that the demand for each spread depends on its price as follows:*
>	`Dd = 190 - 25*Pd`  and  `Dr = 250 - 50*Pr`
*where `D` denotes demand (in pounds), `P` denotes price (in dollars per pound), and the subscripts `d` and `r` refer to the delux and regular spreads, respectively. How many pounds of each spread should the cheese shop prepare, and what prices should it establish, if it wishes to maximize income and be left with no inventory of either spread at the end of Christmas week?*"

If `X` denotes the amount of each spread to be made. the objective is to maximize `Pd*Xd_Pr*Xr`. To eliminate excess inventory, production must not exceed demand, i.e., `Xd=<Dd` and `Xr=<Dr`. Fom the availability of the raw ingredients, `0.2*X1+0.2*X2=<20` and `0.8*X1+0.3*X2=<60`. The solution is given by:
eg
	﻿?- [Xd,Xr,Pd,Pr]::real(0,_), OF=Pd*Xd+Pr*Xr,
	local_maxima(OF,{0.2*Xd+0.2*Xr=<20, 0.8*Xd+0.3*Xr=<60, Xd=<190-25*Pd, Xr=<250-50*Pr}),
	global_maximum(OF,Income), splitsolve([Xd,Xr,Pd,Pr]).
	OF = Pd*Xd+Pr*Xr,
	Xd:: 55.00000...,
	Xr:: 45.00000...,
	Pd:: 5.4000000...,
	Pr:: 4.1000000...,
	Income:: 481.50000000000... ;
	false.
The maximum income of $481.50 can be realized by making (and selling) 55 pounds of deluxe spread at $5.50/pound, and 45 pounds of of regular at $4.10/pound. (This example runs over 50 times faster with local optima constraints applied.)

##### Refinery Location
"*A major oil company wants to build a refinery that will be supplied from three port cities. Port B is located 300 km east and 400 km north of Port A, while Port C is 400 km east and 100 km south of Port B. Determine the location of the refinery so that the total amount of pipe required to connect the refinery to the ports is minimized.*"

The objective is to minimize the distance between the refinery and the three ports. Assuming a coordinate system with Port A at ` (0,0) ` the objective function becomes:
>	`sqrt(X**2+Y**2)+sqrt((X-300)**2+(Y-400)**2)+sqrt((X-700)**2+(Y-300)**2)`
where the refinery is located at `(X,Y)`. A (redundant) constraint to minimize the search space is that the refinery must lie within the box bounded by the ports, which imposes an upper bound on `X` of 700, and on `Y` of 400. This is an unconstrained global optimization which will just use simple gradient constraints:
eg
	﻿?- X::real(0,700),Y::real(0,400),
	OF = sqrt(X**2+Y**2)+sqrt((X-300.0)**2+(Y-400.0)**2)+sqrt((X-700.0)**2+(Y-300.0)**2),
	local_minima(OF), global_minimize(OF,Pipe).
	OF = sqrt(X**2+Y**2)+sqrt((X-300.0)**2+(Y-400.0)**2)+sqrt((X-700.0)**2+(Y-300.0)**2),
	X:: 311.096...,
	Y:: 369.331...,
	Pipe:: 910.543... .


##### Caveats

A number of global, local, and linear optimization predicates, in combination with the labelling predicates (`solve` and friends) are provided because when it comes to optimization problems, not one size fits all. The general techniques can be deceptively simple and declarative. However, one must remember that they are based on exhaustive search which can be very expensive. When the problem allows, alternative techniques, e.g., as supported by `library(simplex)` for linear problems, should be used. When this can't be done, applying hidden and redundant constraints can result in a significant improvement, as will any reduction in the precision requirements (third argument of `global_max...` and `global_min...`). 

A second issue is that the objective function passed to global optimum predicates must contain sufficient free values (intervals) so that solutions can be fully tested. Consider the following simple change to the "Refinery Location" example:
eg
	﻿?- X::real(0,700),Y::real(0,400),
	OF = sqrt(X**2+Y**2)+sqrt((X-300.0)**2+(Y-400.0)**2)+sqrt((X-700.0)**2+(Y-300.0)**2),
	local_minima(OF), {OF==Z}, global_minimize(Z,Pipe).
	OF = sqrt(X**2+Y**2)+sqrt((X-300.0)**2+(Y-400.0)**2)+sqrt((X-700.0)**2+(Y-300.0)**2),
	Z = Pipe,
	X::real(255.67478448957934, 472.3010561622925),
	Y::real(189.84791399187418, 400),
	Pipe:: 691.798... .
Here `{OF==Z}` has been applied before calling `global_minimize` which now only has `Z` and its constraints to use. Searching for a minima using only `Z` is problematic because full narrowing is only possible when there is no dependancy problem, which is often not the case. In this example, an invalid minimum has been reached. If `solve` is used to furether constrain `X` and `Y`, it will fail:
eg
	﻿?- X::real(0,700),Y::real(0,400),
	OF = sqrt(X**2+Y**2)+sqrt((X-300.0)**2+(Y-400.0)**2)+sqrt((X-700.0)**2+(Y-300.0)**2),
	local_minima(OF), {OF==Z}, global_minimize(Z,Pipe), solve([X,Y]).
	false.
When there is insufficient correlation between the objective function and the set of constrained variables, a custom "branch and bound" technique is necessary.

Global optimization is a hard problem and the tools described in this section are not the only way to tackle it. Alternative searching techniques and numerical methods can be applied which can be more effective in particular problem domains. Domain specific constraints which may be hidden in the original problem statement should almost always be used to prune what can be a very large search space.

<#TableOfContents>

&
	[New Computer Methods for Global Optimization] <- link https://pages.cpsc.ucalgary.ca/~rokne/global_book.pdf
	[Schaum's Outlines, Operations Research] <- link https://www.amazon.com/gp/product/B00AUGCJD0/ref=dbs_a_def_rwt_bibl_vppi_i1
	[Karush–Kuhn–Tucker] <- link https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions
	[Knapsack Problem] <- link https://en.wikipedia.org/wiki/Knapsack_problem
	[[SWIP Manual - Arithmetic]] <- link https://www.swi-prolog.org/pldoc/man?section=arith
	[The Stigler Diet Problem] <- link https://developers.google.com/optimization/lp/stigler_diet
	[Appendix - Bin_Packing_Examples] <- link #toc4Appendix_3_-_Bin_Packing_Examples
	